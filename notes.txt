Script tag always at end of body tag, to let HTML load fully

JS Notes
	DataTypes
		Number
		String
		Boolean
		undefined
		null
		Symbol //ES2015
		BigInt //ES2020
		
		typeof null -> Object //error in JS which is not likely to be corrected	
		Symbol is used to create and hold unique values
	
	MISC
	Destructuring
		Arrays 
			Array Destructuring happens based on array index position
			Swapping variables
				let arr = [1,2]
				let [a,b] = arr
				[a,b] = [b,a] //will swap a=2,b=1
			Nested Destructuring
				const [a,[b,c]] =[5,[6,7],8] // gives a=5,b=6,c=7
			Defaulting
				const [a,b,c=5] = [1,2,3] // gives a=1,b=2,c=3
				const [a,b,c=5] = [1,2] // gives a=1,b=2,c=5 (as per value array c is undefined so it is defaulted to 5)
			Skipping values
				const [a,,b] =[4,5,6] // gives a=4,b=6 

				const [data,length] = someFunc() // Destructuring can be used to store returned data as well
		Object Destructuring
			Object Destructuring happens based on Key name
				const Person = {name:"Logan",age:27,job:developer}
				const {name,job} = Person // creates name and job variable
			Orderless
				const {job,age} = Person // since based on key name order does not matter
			Alias
				const {job : designation,age : old} = Person // creates designation and old variables with job and age's value. i.e before : is value and after : is variable Alias
			Defaulting
				const {job : designation = "VIP"} = Person // Defaulting with alias
			Mutating variables
				let a=100,b=200;
				const obj = {a:1,b:2,c:7}
				{a,b} = obj // error: unexpected token '=' -> because {} is considered code block syntax error is thrown
				({a,b} = obj) // enclose above line with () to avoid syntax error // result a=1,b=2
			Nested Destructuring
				const Person = {name:"Logan",age:27,job:developer,address:{street:"100 king st",zip:60004}}
				const {address:{street,zip}} = Person

	Compilation
		JS is now Just in Time (JIT) complied, before execution. whith following phases
		Parsing - Code is parsed to check for errors and to create an Abstract Syntax Tree (AST)
		Compilation - AST is converted to machine Code to be stored in call stack
		Execution - Code is executed based on call stack

	Operators
		Creating variable without let,const or var will create a property in global object and will not throw error in non strict mode
		** -> exponent operator i.e 2 ** 4 => 2*2*2*2 //4 times 2
		mdn operator precedence //mdn mozilla dev network

		Spread
			'...' to take out values from Iterables & objects
			Spread can be used in areas where we are allowed to specify CSV. i.e inside array, passing function arguments,console.log etc 
			const arr =[1,2,3,4,5,6]
			const arr1 = [...arr,7,8,9] // will create new copy of arr [1,2,3,4,5,6,7,8,9]
			Uses
				Shallow copy
				merge two Iterable (eg [...arr,...arr1])
				String to string array
					const str = "Logan"
					const strArr = [...str,] // creates string arr ['L','o','g','a','n']

		Logical Operators
			In javascript Logical Operators can do the following
				1. Use any DataType
				2. Return any DataType
				3. Do short Circuiting
			&&
				Short Circuiting
					(condition1 || condition2) // if condition1 is true condition2 is evaluated
					Will return first falsey value or last value
					JS returns condition1 immediately if its false, without evaluating condition2, only if condition1 is true condition2 is returned irrespectively
					Used to evaluate second expression if first is true (like an if condition)
					Scenarios
						const test = 23
						(test && functionCall(test)) // calls the function only if test has a truthy value

			||
				Short Circuiting
					(condition1 || condition2) // if condition1 is false condition2 is evaluated
					Will return first truthy value or last value
					JS returns condition1 if its true, immediately without evaluating condition2, only if condition1 is false condition2 is returned irrespectively
					Used to set default values
					Scenarios
						const test = 23
						const test1 = test || 10 // this is equal to test ? test : 10
			?? - es 2020
				this is same as || but sends false only for null and undefined


	Flasey values 
		0
		'' // empty String
		undefined
		null
		NaN
		
	Switch(case)
		case 1:
		 log(1)
		 break
		 case 2:
		 case 3:
		 log(5)  // will print 5 for both 2 & 3
		 
		 Switch case without break will execute next case as well (unconditionally) until it finds break
		 
	Math
		Math.max(//csv),Math.min(//csv) to return min max values of numerical csv alone 
		
		
	Console
		console.log() - Print in console as message
		warn() - Print in console as warning
		error()  - Print in console as error
		table()  - Prints array/object in table format
		
	Debug
		debugger; // write this in js file at specific position to open dev tools with breakpoint at the position
	Functions
		Functions can be declarations or Expressions
		
		const testFunc = function () {//definition}  //function Expression
		function testFunc1() { //function declaration
			..definition
		}
		Note: Function declaration can be called even before definition
			
			//will work
			testFunc1() 
			function testFunc1() { 
				..definition
			}

			//will not work
			testFunc()
			const testFunc = function () {//definition}
	
    DOM
        document.querySelector(//css selector syntax)
        innerHTML vs innerText vs textContent
            innerHTML -> parses and provide as HTML
            innnerText -> just text no parsing of HTML
            textContent -> sets text content alone

	Scoping
		Lexical scoping - Js is lexically scope (child can access parent and function can access Golbal variables)
		After ES6 functions declared inside othr blocs are also block scoped in Strict mode alone. i.e in strict mode after ES6
		if a funtions in decarled inside if(){} it is accessible only inside if
		'var' still has no block or function scopes

	Window
		'var' decarled at global level create a property in window pbject. i.e if we create var x= 10 -> window.x will be created with value 10

	This
		this keyword in not same always
		In general 'this' is a special variable created inside every execution context (function, object). 
		It points to the owner of the function
		'this' is not a static variable. It depends on how function is called and value is assigned to 'this' only when function is called
		
		4 ways of calling function
		
		1.If normal function (not arrow function) is a method inside an object 'this' will refer to the Object 
		
		const Person = {
			Name:"Logan",
			Year:1994,
			calcAge:function() {
				return 2021 - this.Year   // output: 27; here this point to Person Object
			}
			calcAge1: year => {
				year - this.Year // output: NaN; here this points to window object 
			}
		}

		2. Global scoped function definition/declaration will point to undefined in strict mode and window object if not in strict mode

		'use strict';

		const calcAge = function() {
				console.log(this)   // strict mode will log undefined; else window object 
			}

		3. Arrow functions does not have 'this' for itself, instead it points to 'this' around it (lexically accessible parent 'this')

		4.eventListner, if 'this' is used inside eventListner of the element, this will refer to the DOM element


		Note: 'this' will never point to the funtion or the variable environment

	Data Structures
		Iterable (iterateable)
			Array
			String
			Map
			Set
		Non Iterable
			Objects

		Array
		console.log([10,10,10] + 10) //prints "10,10,1010" as string
		console.log([10,10,10] - 10) //prints NaN
		
		Array Methods
			array.push('test') -> adds 'test' to end of array and returns length of array
			array.unshift('test')-> adds 'test' to start of array and returns length of array
			array.pop() -> will remove and return last element of the array
			array.shift() -> will remove and return first element of the array
			array.indexOf('test') -> returns index of 'test', if element is not present -1 is returned
			array.includes('test') -> returns true/false if its present (=== strict equal) or not in Array //ES6 method

			array.entries() -> returns an array with index in 0 and value in 1 position eg. [[0,'a'],[1,'b']]

		Optional Chaining
			?. can be used to perform Optional Chaining in array of objects
			const arr = [{data:"100"}]
			console.log(arr[1].data) // will throw error
			console.log(arr[1]?.data) // will print undefined

		Objects
			Objects are used to store Key value pairs, where key is always a string and value can be of any datatype

			Object Methods
				const obj = {a:11,b:12,c:13,d:14}
				Object.keys(objName) -> returns an array with all the keys in object ['a','b','c','d']
				Object.values(objName) -> returns an array with all the values in object [11,12,13,14]
				Object.entries(objName) -> returns an array with keys in 0 and value in 1 position eg. [['a',11],['b',12]....]
			Enhanced Object literals
				Major Enhancements on Object literals are
				1. Setting variable alone creates a property in object with same variable name and sets it to it
				2. Functions can be configured in funcName(){} directly where funcName is considered as the key
				3. use [] in the key side to evalute any expression inside to arrive at a dynamic keyname
				const Address = {add1:"No 6", street:"Vivekanandar Theru",city:"Dubai main rd"}

				const Person = {
					Name:"Logan",
					Address, // same as Address: Address
					calcAge(age){  // same as calcAge : function(){}
						return 2021 - age
					},
					['Bini'+'Babu']:"dost" // using [] is used to set dynamic key name after evaluating expression inside it
				}
			Optional Chaining - es 2020
				Using ?. to access property of object is called Optional Chaining and its returns undefined as soon as property is not found in the object
				Scenarios
					const Person = {
						Name:"Logan",
						Address:{StreetNum:"No6"}
					}
					Person.Address.Address1.StreetName // throws unable to find property StreetName of undefined
					Person?.Address?.Address1?.StreetName // returns undefined right after Address1 without throwing error
					Person?.Address[Address1]?.StreetName // can be used with [] as well

					Person?.calcAge?.(1994) // method is invoked only if its available

		Sets
			Collection of unique values (kind of Hashset)
			Supports mixed dataTypes as well
			const tempSet = new Set(<Iterable>) // can be used with any iterable

			const tempSet = new Set([1,2,3,1,2,4,3]) // will store only unique values // result : [1,2,3,4]

			Set Methods
				tempSet.add(6) // adds element
				tempSet.delete(6) // removes element
				tempSet.size // returns size (length)
				tempSet.has(5) // returns true or false based on values being present in set
				tempSet.clear() // clears entire set

				Note: We can use for of to iterate through Sets

				Scenarios
					Remove duplicates from Array
					let arr = [1,2,3,4,5,1,2,4,2]
					arr = [...new Set(arr)] // set will remove duplicates and Spread operator gives new array from the set
		Maps
			Map is used to store Key value pair as well, but unlike objects Map can have keys and values of any datatype
				const mMap = new Map()
			Map Methods
				mMap.set(Key,value) // set value in key and returns new Map
				mMap.set(Key,value).set(Key1,value1) // set() can be chained as it returns new Map always
				
				mMap.get(key) // returns the value if key is present else undefined
				mMap.has(key) // returns booelan if key is present or not
				mMap.delete(key)
	Loop
		For of Loop
			Arrays
				const arr = ['a','b','c']

				for(const a of arr) console.log(a) // will print each index one by one

				Use arr.entries() method to get index in for of loop  
					for(const [index,element] of arr.entries()) console.log(`${index+1}:${element}`) //output: 1: a ....


			Objects
