Script tag always at end of body tag, to let HTML load fully

JS Notes
	DataTypes
		Number
		String
		Boolean
		undefined
		null
		Symbol //ES2015
		BigInt //ES2020
		
		typeof null -> Object //error in JS which is not likely to be corrected	
		Symbol is used to create and hold unique values
	
	MISC
	Destructuring
		Arrays 
			Array Destructuring happens based on array index position
			Swapping variables
				let arr = [1,2]
				let [a,b] = arr
				[a,b] = [b,a] //will swap a=2,b=1
			Nested Destructuring
				const [a,[b,c]] =[5,[6,7],8] // gives a=5,b=6,c=7
			Defaulting
				const [a,b,c=5] = [1,2,3] // gives a=1,b=2,c=3
				const [a,b,c=5] = [1,2] // gives a=1,b=2,c=5 (as per value array c is undefined so it is defaulted to 5)
			Skipping values
				const [a,,b] =[4,5,6] // gives a=4,b=6 

				const [data,length] = someFunc() // Destructuring can be used to store returned data as well
		Object Destructuring
			Object Destructuring happens based on Key name
				const Person = {name:"Logan",age:27,job:developer}
				const {name,job} = Person // creates name and job variable
			Orderless
				const {job,age} = Person // since based on key name order does not matter
			Alias
				const {job : designation,age : old} = Person // creates designation and old variables with job and age's value. i.e before : is value and after : is variable Alias
			Defaulting
				const {job : designation = "VIP"} = Person // Defaulting with alias
			Mutating variables
				let a=100,b=200;
				const obj = {a:1,b:2,c:7}
				{a,b} = obj // error: unexpected token '=' -> because {} is considered code block syntax error is thrown
				({a,b} = obj) // enclose above line with () to avoid syntax error // result a=1,b=2
			Nested Destructuring
				const Person = {name:"Logan",age:27,job:developer,address:{street:"100 king st",zip:60004}}
				const {address:{street,zip}} = Person

	Compilation
		JS is now Just in Time (JIT) complied, before execution. whith following phases
		Parsing - Code is parsed to check for errors and to create an Abstract Syntax Tree (AST)
		Compilation - AST is converted to machine Code to be stored in call stack
		Execution - Code is executed based on call stack

	Operators
		Creating variable without let,const or var will create a property in global object and will not throw error in non strict mode
		** -> exponent operator i.e 2 ** 4 => 2*2*2*2 //4 times 2
		mdn operator precedence //mdn mozilla dev network

		Spread
			'...' to take out values from Iterables & objects
			Spread can be used in areas where we are allowed to specify CSV. i.e inside array, passing function arguments,console.log etc 
			const arr =[1,2,3,4,5,6]
			const arr1 = [...arr,7,8,9] // will create new copy of arr [1,2,3,4,5,6,7,8,9]
			Uses
				Shallow copy
				merge two Iterable (eg [...arr,...arr1])
				String to string array
					const str = "Logan"
					const strArr = [...str,] // creates string arr ['L','o','g','a','n']

		Logical Operators
			In javascript Logical Operators can do the following
				1. Use any DataType
				2. Return any DataType
				3. Do short Circuiting
			AND
			
			OR
				Short Circuiting
					(condition1 || condition2) 
					JS returns condition1 immediately without evaluating condition2, only if condition1 is false condition2 is returned irrespectively

					Scenarios
						const test = 23
						const test1 = test || 10 // this is equal to test ? test : 10



	Flasey values 
		0
		'' // empty String
		undefined
		null
		NaN
		
	Switch(case)
		case 1:
		 log(1)
		 break
		 case 2:
		 case 3:
		 log(5)  // will print 5 for both 2 & 3
		 
		 Switch case without break will execute next case as well (unconditionally) until it finds break
		 
	Math
		Math.max(//csv),Math.min(//csv) to return min max values of numerical csv alone 
		
		
	Console
		console.log() - Print in console as message
		warn() - Print in console as warning
		error()  - Print in console as error
		table()  - Prints array/object in table format
		
	Debug
		debugger; // write this in js file at specific position to open dev tools with breakpoint at the position
	Functions
		Functions can be declarations or Expressions
		
		const testFunc = function () {//definition}  //function Expression
		function testFunc1() { //function declaration
			..definition
		}
		Note: Function declaration can be called even before definition
			
			//will work
			testFunc1() 
			function testFunc1() { 
				..definition
			}

			//will not work
			testFunc()
			const testFunc = function () {//definition}
			
	Array
		console.log([10,10,10] + 10) //prints "10,10,1010" as string
		console.log([10,10,10] - 10) //prints NaN
		
		Array Methods
			Array.push('test') -> adds 'test' to end of array and returns length of array
			Array.unshift('test')-> adds 'test' to start of array and returns length of array
			Array.pop() -> will remove and return last element of the array
			Array.shift() -> will remove and return first element of the array
			Array.indexOf('test') -> returns index of 'test', if element is not present -1 is returned
			Array.includes('test') -> returns true/false if its present (=== strict equal) or not in Array //ES6 method
	
    DOM
        document.querySelector(//css selector syntax)
        innerHTML vs innerText vs textContent
            innerHTML -> parses and provide as HTML
            innnerText -> just text no parsing of HTML
            textContent -> sets text content alone

	Scoping
		Lexical scoping - Js is lexically scope (child can access parent and function can access Golbal variables)
		After ES6 functions declared inside othr blocs are also block scoped in Strict mode alone. i.e in strict mode after ES6
		if a funtions in decarled inside if(){} it is accessible only inside if
		'var' still has no block or function scopes

	Window
		'var' decarled at global level create a property in window pbject. i.e if we create var x= 10 -> window.x will be created with value 10

	This
		this keyword in not same always
		In general 'this' is a special variable created inside every execution context (function, object). 
		It points to the owner of the function
		'this' is not a static variable. It depends on how function is called and value is assigned to 'this' only when function is called
		
		4 ways of calling function
		
		1.If normal function (not arrow function) is a method inside an object 'this' will refer to the Object 
		
		const Person = {
			Name:"Logan",
			Year:1994,
			calcAge:function() {
				return 2021 - this.Year   // output: 27; here this point to Person Object
			}
			calcAge1: year => {
				year - this.Year // output: NaN; here this points to window object 
			}
		}

		2. Global scoped function definition/declaration will point to undefined in strict mode and window object if not in strict mode

		'use strict';

		const calcAge = function() {
				console.log(this)   // strict mode will log undefined; else window object 
			}

		3. Arrow functions does not have 'this' for itself, instead it points to 'this' around it (lexically accessible parent 'this')

		4.eventListner, if 'this' is used inside eventListner of the element, this will refer to the DOM element


		Note: 'this' will never point to the funtion or the variable environment

	Data Structures
		Iterable (iterateable)
			Array
			String
			Map
			Set
		Non Iterable
			Objects
			