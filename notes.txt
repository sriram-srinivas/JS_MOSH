Script tag always at end of body tag, to let HTML load fully

JS Notes
	DataTypes
		Number
		String
		Boolean
		undefined
		null
		Symbol //ES2015
		BigInt //ES2020
		
		typeof null -> Object //error in JS which is not likely to be corrected	
		Symbol is used to create and hold unique values
	
		Strings
			const str = "Logan"
			console.log(str[0]) // prints L
			console.log('ETHAN'[0]) // prints E

			String Methods
				All/Most string comparison methods are case sensitive

				str.indexOf('a') // returns position of 'a'  in str
				str.lastIndexOf('a') // returns position of last 'a' occurence in str 
				str.includes('an') // returns boolean based on substring is present or not
				str.startsWith('Lo') // returns boolean based on string starts with substring or not
				str.endsWith('Lo') // returns boolean based on string ends with substring or not
				str.slice(startIndex) // returns string from the mentioned start index str.slice(1) gives 'ogan'
					-ve index will extract from end str.slice(-2) returns 'an'
				str.slice(start,end) // returns substring from start and before end str.slice(1,3) gives 'og'
				str.toLowerCase() // returns lowercase String
				str.toUpperCase() // returns uppercase String
				str.trim()// returns string with whitespace removed from start and end of string
				str.replace(targetString,stringReplacement) // returns string after replacing first occurence of targetString with stringReplacement. Note: use regex /string/g to replaceAll str.replace(/a/g,'b') will replace all a with b

				str.split(delimiter) // returns array 
				str.padStart(20,'*') // returns a string of length 20 by adding 20 - str.length * before str String// result : **************Logan
				str.padEnd(20,'+') // returns a string of length 20 by adding 20 - str.length + after str String// result : Logan++++++++++++++ 
				str.repeat(5) // repeats str 5 times and returns string
				Chaining
					String method chaining is possible as almost every string method returns modified string
					str.toLowerCase().trim() // returns lowercased and trimmed str

	MISC
		Destructuring
			Arrays 
				Array Destructuring happens based on array index position
				Swapping variables
					let arr = [1,2]
					let [a,b] = arr
					[a,b] = [b,a] //will swap a=2,b=1
				Nested Destructuring
					const [a,[b,c]] =[5,[6,7],8] // gives a=5,b=6,c=7
				Defaulting
					const [a,b,c=5] = [1,2,3] // gives a=1,b=2,c=3
					const [a,b,c=5] = [1,2] // gives a=1,b=2,c=5 (as per value array c is undefined so it is defaulted to 5)
				Skipping values
					const [a,,b] =[4,5,6] // gives a=4,b=6 

					const [data,length] = someFunc() // Destructuring can be used to store returned data as well
			Object Destructuring
				Object Destructuring happens based on Key name
					const Person = {name:"Logan",age:27,job:developer}
					const {name,job} = Person // creates name and job variable
				Orderless
					const {job,age} = Person // since based on key name order does not matter
				Alias
					const {job : designation,age : old} = Person // creates designation and old variables with job and age's value. i.e before : is value and after : is variable Alias
				Defaulting
					const {job : designation = "VIP"} = Person // Defaulting with alias
				Mutating variables
					let a=100,b=200;
					const obj = {a:1,b:2,c:7}
					{a,b} = obj // error: unexpected token '=' -> because {} is considered code block syntax error is thrown
					({a,b} = obj) // enclose above line with () to avoid syntax error // result a=1,b=2
				Nested Destructuring
					const Person = {name:"Logan",age:27,job:developer,address:{street:"100 king st",zip:60004}}
					const {address:{street,zip}} = Person

		Compilation
			JS is now Just in Time (JIT) complied, before execution. whith following phases
			Parsing - Code is parsed to check for errors and to create an Abstract Syntax Tree (AST)
			Compilation - AST is converted to machine Code to be stored in call stack
			Execution - Code is executed based on call stack

		Closure
			Closure in an internal concept in JS, Which is
				1. A function has access to the variable environment of the execution context in which it was created
				2. Closure is the concept of attaching this variable environment as it is when the function is created

			eg:
			1.	function temp(){
					let counter =0;
					return function(){
						counter++;
						console.log(`${counter}`)
					}
				}

				const incrementer = temp() // stores returned function

				incrementer(); // 1
				incrementer(); // 2
				incrementer(); // 3

				The above concept of returned function accessing the counter variable of the completed function is because of closure

			2. let f;

				const g = function(){
					const a=4
					f= function(){
						console.log(a*2)
					}
				}

				g(); // sets f as a function
				f(); //  8

				Another Scenario where scope of a is available for f is a closure

			3. callback set in SetTimeout with variable created outside, is a similar example for closure
		
		Internationalizing
			Date
				Used to change date time format based on location
					const Dte = new Intl.DateTimeFormat(locale,options).format(date) // for locale 'en-US' and date now() will give today's date in us format
					const options ={
						hours:'numeric',
						minute:'numeric',
						day:'numeric',
						month:'long',
						year:'2-digit'
						weekday:'short'
					}						// sending above option will print 'Sat February 12/22 2:45 pm'
			Number
				Used to change Number format based on location
					const Dte = new Intl.NumberFormat(locale,options).format(Num) // for locale 'en-US' and Number 1000 will give today's 1,000 in us format
					const options ={
						style:'unit',   // unit/currency/percent etc
						unit:'degree', // prints in temperature degree, other units miles-per-hour 
						currency:'USD' // prints either $1,000 or 1000 $US based on local, other value EUR 
					}						

		SetTimeout
			To perform a function call after specific timeout
				setTimeout(function,delay,args1,args2...) // This will call the 'function' parameter, after 'delay' milliseconds with parameter to function 'args1,arg2'
				setTimeout(()=>console.log("after 3 secs"),3000) //prints msg after 3000 milliseconds
			
			We can clear the setTimeout before the delay time by doing the below
				const timer = setTimeout(function,delay,args1,args2...)
				clearTimeout(timer) // this clears the timer and callback will not execute
		SetInterval
			To perform a function call repeatedly with specific time interval
				setInterval(function,delay,args1,args2...) // This will call the 'function' parameter, repeatedly after every 'delay' milliseconds with parameter to function 'args1,arg2'
				setInterval(()=>console.log("every 3 secs"),3000) //prints msg every 3000 milliseconds
			
			We can clear the setInterval before the delay time by doing the below
				const interval = setInterval(function,delay,args1,args2...)
				clearInterval(interval) // this clears the interval and callback will not execute anymore
		

	Operators
		Creating variable without let,const or var will create a property in global object and will not throw error in non strict mode
		Note: Variables created with var are also stored in Global object
		** -> exponent operator i.e 2 ** 4 => 2*2*2*2 //4 times 2
			use the above to find Cubic Root 8 ** (1/3) // print 2 (2*2*2)
		mdn operator precedence //mdn mozilla dev network

		Spread
			'...' to take out values from Iterables & objects
			Spread can be used in areas where we are allowed to specify CSV. i.e inside array, passing function arguments,console.log etc 
			const arr =[1,2,3,4,5,6]
			const arr1 = [...arr,7,8,9] // will create new copy of arr [1,2,3,4,5,6,7,8,9]
			Uses
				Shallow copy
				merge two Iterable (eg [...arr,...arr1])
				String to string array
					const str = "Logan"
					const strArr = [...str,] // creates string arr ['L','o','g','a','n']

		Logical Operators
			In javascript Logical Operators can do the following
				1. Use any DataType
				2. Return any DataType
				3. Do short Circuiting
			&&
				Short Circuiting
					(condition1 && condition2) // if condition1 is true condition2 is evaluated
					Will return first falsey value or last value
					JS returns condition1 immediately if its false, without evaluating condition2, only if condition1 is true condition2 is returned irrespectively
					Used to evaluate second expression if first is true (like an if condition)
					Scenarios
						const test = 23
						(test && functionCall(test)) // calls the function only if test has a truthy value

			||
				Short Circuiting
					(condition1 || condition2) // if condition1 is false condition2 is evaluated
					Will return first truthy value or last value
					JS returns condition1 if its true, immediately without evaluating condition2, only if condition1 is false condition2 is returned irrespectively
					Used to set default values
					Scenarios
						const test = 23
						const test1 = test || 10 // this is equal to test ? test : 10
			?? - es 2020
				this is same as || but sends false only for null and undefined


	Flasey values 
		0
		'' // empty String
		undefined
		null
		NaN
		
	Switch(case)
		case 1:
		 log(1)
		 break
		 case 2:
		 case 3:
		 log(5)  // will print 5 for both 2 & 3
		 
		 Switch case without break will execute next case as well (unconditionally) until it finds break
		 
	Math
		Math.sqrt(25) // 5
		Math.max(csv)
		Math.min(csv) to return min max values of numerical csv alone 
		Math.abs(-10) // 10 // get unsigned value
		Math.trunc(val) //without decimal
		Math.PI//3.14
		Math.random() // gives an random decimal number between 0 & 1
		Math.round() // round to nearest integer
		Math.ceil() 
		Math.floor()
		
		Note: Both ceil() floor() for negative number works opposite

	Console
		console.log() - Print in console as message
		warn() - Print in console as warning
		error()  - Print in console as error
		table()  - Prints array/object in table format
		
	Debug
		debugger; // write this in js file at specific position to open dev tools with breakpoint at the position
	Functions
		Functions can be declarations or Expressions
		
		const testFunc = function () {//definition}  //function Expression
		function testFunc1() { //function declaration
			..definition
		}
		Note: Function declaration can be called even before definition
			
			//will work
			testFunc1() 
			function testFunc1() { 
				..definition
			}

			//will not work
			testFunc()
			const testFunc = function () {//definition}
		Function methods
			const testFunc = function (param1,param2){
				console.log(`${this.name} ${param1} ${param2}`)
			}
			testFunc.call(thisVar,arg1,arg2,..) -> Calls function testFunc with 'this' variable pointing to 1st argument 'thisVar' and remaining arg1 & 2 are testFunc's arguments 

			testFunc.apply(thisVar,[arg1,arg2,..]) -> same as call() but expects argument array as second argument
			
			testFunc.bind(thisVar) -> returns a function which has its 'this' set to 'thisVar'
			const testFuncWithThis =testFunc.bind(thisVar,arg1) -> same as above but first parameter of funcName is also set to arg1 
			testFuncWithThis(arg2) // since this and 1st param is set above only arg2 is needed to call

			testFunc1.bind(null,arg1) -> use this to just set fixed parameter (since this is not needed it is set to null)

		IIFE - Immediately Invoked Function Expression
			An Immediately-invoked Function Expression is a way to execute functions immediately, as soon as they are created. IIFEs are very useful because they don't pollute the global object, and they are a simple way to isolate variables declarations
			(function(){
				const test = 100
				console.log("IIFE")
			})(); // this is an IIFE code pattern invoked only once ( to create a specific scope before ES6 bolck scope)

			(() => console.log("Arrow IIFE"))() // works for arrow function as well
			
			//Named IIFE
			(function testIIFE(){
				console.log("Named IIFE")
			})()

			testIIFE(); // will throw reference error
    DOM
        document.querySelector(//css selector syntax)
        innerHTML vs innerText vs textContent
            innerHTML -> parses and provide as HTML
            innnerText -> just text no parsing of HTML
            textContent -> sets text content alone

	Advanced DOM
		DOM -> Document object model
		Node -> Node is the individual part in DOM; It has different types; Note: Every node is an JS object
			Document Node -> Contains all dom manipulation methods (createElement,getElementById,querySelector), Global objects etc
			Element Node -> This Node is created only for HTML elements contains all common attributes of HTML elements 
							It has 'chidType' attribute which specifies html element node 
						HTMLElementNode -> Each html tag (div,a,img) has its own node(js objext) and has properties specific to that node (eg a-> href, img -> src) 
			Text Node -> This node will be created for Texts inside tags
			Comment Node -> All html content needs to be mapped in DOM so also comments will have its own nodes 
		Event Type -> Parent node of all nodes (addEventListner is a property of this Node and all tags recieve this attribute as part of inheritance/prototyping)
		document -> Document Object which has all DOM maipulation methods and attributes(Document Type Node)
		document.documentElement -> It returns actual HTMLElement node of tag 'html' (document.documentElement === document.getElementsByTagName("html")[0] // true)
		
		Note: All Node is reperesented in the form of JS objects and Every Node type has its own set of attributes and methdods
			  ALso Node has hierarchies and all Node properties are shared using prototyping

		NodeList -> A List of nodes that is snapshot of what was available when executed, does not Automatically change with change in DOM (unless invoked again)
		HTMLCollection -> A live collection list, which changed along with any change in dom; getElementsByTagName,getElementsByClassName etc return HTMLCollection
		
		Select DOM Elements -> all below methods can be call with document object or other HTMLElement objects too(this determines the scope of selection)
			getElementById(//id of tag) //returns single HTMLElement
			getElementsByClassName(//css class name) // returns HTMLCollection
			getElementsByTagName(//tag name) // returns HTMLCollection
			getElementsByTagNameNS(//tag name,//namespace) // returns HTMLCollection
			getElementsByName(//name attribute) //returns NodeList 
			querySelector(//css selector) //returns single HTMLElement
			querySelectorAll(//css selector) //returns NodeList

		Create DOM Elements
			
			element.insertAdjacentHTML(position, html); // 'element' is selector; 'position' ("afterbegin","afterend","beforebegin","beforeend") & 'html' content to insert
				const h = document.getElementById(id);
				h.insertAdjacentHTML("afterend", "<p>My new paragraph</p>"); this create a <p> element and inserts it after 'h'

			
	Scoping	
		Lexical scoping - Js is lexically scope (child can access parent and function can access Golbal variables)
		After ES6 functions declared inside othr blocs are also block scoped in Strict mode alone. i.e in strict mode after ES6
		if a funtions in decarled inside if(){} it is accessible only inside if
		'var' still has no block or function scopes

	Window
		'var' decarled at global level create a property in window object. i.e if we create var x= 10 -> window.x will be created with value 10

	This
		this keyword in not same always
		In general 'this' is a special variable created inside every execution context (function, object). 
		It points to the owner of the function
		'this' is not a static variable. It depends on how function is called and value is assigned to 'this' only when function is called
		
		4 ways of calling function
		
		1.If normal function (not arrow function) is a method inside an object 'this' will refer to the Object 
		
		const Person = {
			Name:"Logan",
			Year:1994,
			calcAge:function() {
				return 2021 - this.Year   // output: 27; here this point to Person Object
			}
			calcAge1: year => {
				year - this.Year // output: NaN; here this points to window object 
			}
		}

		2. Global scoped function definition/declaration will point to undefined in strict mode and window object if not in strict mode

		'use strict';

		const calcAge = function() {
				console.log(this)   // strict mode will log undefined; else window object 
			}

		3. Arrow functions does not have 'this' for itself, instead it points to 'this' around it (lexically accessible parent 'this')

		4.eventListner, if 'this' is used inside eventListner of the element, this will refer to the DOM element


		Note: 'this' will never point to the funtion or the variable environment, Also check Function Methods to know how to modify 'this' binding

	Data Structures
		Iterable (iterateable)
			Array
			String
			Map
			Set
		Non Iterable
			Objects

		Array
			console.log([10,10,10] + 10) //prints "10,10,1010" as string
			console.log([10,10,10] - 10) //prints NaN

			Arrays are actual JS objects, which get predefined set of Array methods through prototypal inheritance

		Array Methods
			array.push('test') -> adds 'test' to end of array and returns length of array
			array.unshift('test')-> adds 'test' to start of array and returns length of array
			array.pop() -> will remove and return last element of the array
			array.shift() -> will remove and return first element of the array
			array.indexOf('test') -> returns index of 'test', if element is not present -1 is returned
			array.includes('test') -> returns true/false if its present (=== strict equal) or not in Array //ES6 method
			array.join('*') -> returns string by concating all array index with delimiter

			array.entries() -> returns an array with index in 0 and value in 1 position eg. [[0,'a'],[1,'b']]

			array.slice(startIndex) -> returns new array from startIndex // original is untouched
			array.slice(startIndex, endIndex) -> returns new array from startIndex till endIndex-1
			array.slice(-2) -> returns last 2 elements // using negative index will select elements from end
			array.slice() -> returns shallow copied array

			array.splice(startIndex) -> deletes elements from startIndex of arr and returns it // negative index works as usual
			array.splice(startIndex,deleteCount) -> deletes the deleteCount no of elements from startIndex of arr and returns it
			array.splice(startIndex,deleteCount,element1,element2,...) -> works as above but inserts element1 & element2 at startIndex

			useCase
				arr.splice(1,0,'February') -> at position 1, 0 element(s) are deleted and February is inserted at 1
				arr.splice(2,1,'March') -> remove 1 element at 2 index and 'March' is replaced

			arr.reverse() -> reverses arr array
			arr.concat(arr2) -> returns concatenated array [...arr,...arr2]  

			arr.map(function(currentValue, index, arr), thisValue) -> iterates through array and performs the callback function directly on every index and returns new array
						//currentValue -> currentIndexItem; index -> arrayIndex; arr -> full array; thisValue -> this binding for the callback function
				const a=[1,2,3,4,5]
				const b = a.map(i => i*2) // b = [2,4,6,8,10]

			arr.forEach(function(currentValue, index, arr), thisValue) -> iterate through array but source is untouched
						//currentValue -> currentIndexItem; index -> arrayIndex; arr -> full array; thisValue -> this binding for the callback function
				const a=[1,2,3,4,5]
				const b = a.forEach(i => i*2) // b = undefined

			arr.filter(function(currentValue, index, arr), thisValue) -> iterate through array items and perform function on every index; only the items satisfying condition inside filter funtion is returned in new array; Needs a function that returns a boolean
						//currentValue -> currentIndexItem; index -> arrayIndex; arr -> full array; thisValue -> this binding for the callback function
				const a = [3,5,2,6,1,2]
				const b = a.filter(i => i> 2) // b = [3,5,6]

			arr.reduce(function(total, currentValue, index, arr), initialValue) -> iterate through array and perform function on each item against the 'total' variable 
						//total-> Accumulator | initalize with 'initialValue' and retains value from previous iteration (final return data);currentValue -> currentIndexItem; index -> arrayIndex; arr -> full array; initialValue -> initialValue for the result

				const a = [1,2,3,4,5]
				const b = a.reduce((total,i) => total+i,10) // b =10+1+2+3+4+5 = 25

				Note: The first time that the callback is run there is no "return value of the previous calculation". If supplied, an initial value may be used in its place. Otherwise the array element at index 0 is used as the initial value and iteration starts from the next element (index 1 instead of index 0)

					let arr="1a 2b 3c"
					console.log(arr.toLowerCase().split(" ").reduce((t,a)=>t+a[0])) // will print '1a23'

					let arr="1a 2b 3c"
					console.log(arr.toLowerCase().split(" ").reduce((t,a)=>t+a[0],'')) // will print '123'
				
			arr.find(function(currentValue, index, arr),thisValue) -> returns the value of the first element that passes the condition; Needs a function that returns a boolean
						//currentValue -> currentIndexItem; index -> arrayIndex; arr -> full array; thisValue -> this binding for the callback function
				Note: arr.filter is a findAll method of find(); filter() returns all passed elements in array, whereas find() returns the first passed element itself
			
			arr.findIndex(function(currentValue, index, arr),thisValue) -> same as find() but instead of returning passed element the index of the element is returned

			array.some(()=>{//custom condition}) -> returns true if atleast anyone of the array element satisfies the given custom condition. Array elements are iterated until first satisfied element (return true) 
				const a =[10,20,30,-5]
				a.some(ele => ele > 0) -> will have only one iteration as condition is true for first element itself
				a.some(ele => ele < 0) -> will have full iteration as condition is false until the last element
			
			array.every(()=>{//custom condition}) -> returns true omly if all of the array element satisfies the given custom condition.
				const a =[10,20,30,-5]
				a.every(ele => ele > 0) //returns false
				a.every(ele => ele > -6) //returns true

			//ES2019
			
			array.flat(depth) -> is used to flatten multi level arrays, 'depth' is used to specify no of levels to iteration is needed; by default depth is 1
				const arr1 = [0, 1, 3, [3, [4,4]];
				console.log(arr1.flat()); // [0,1,3,3,[4,4]]

				const arr1 = [0, 1, 3, [3, [4,5]]];
				console.log(arr1.flat(2));// [0,1,3,3,4,5]
			
			array.flatMap(mapObj => mapObj.key)-> inbuit version of arr.map(//function).flat(); used to flat array inside array of Objects; flatMap does only only level of depth, we need to chain with flat() for later levels

				//Indirect implementation
				const temp = [{a:[1,2,3]},{a:[1,2,6]}]
				temp.map(a=>a.a).flat(); // performs [[1,2,3],[1,2,6]] -> [1,2,3,1,2,6]
				
				//Direct implementation
				console.log(temp.flatMap(a=>a.a)); // peforms the same as above [1,2,3,1,2,6]

			Array method Chaining
				We can chain array methods one after the other if the methods return back an array
					arr.filter(//fn).map(//fn).reduce(//fn) is totally possible

				Note: It is a bad practice in JS to chain methods if it mutates original array: i.e do not chain splice() or reverse() methods as it mutates original array

		Optional Chaining
			?. can be used to perform Optional Chaining in array of objects
			const arr = [{data:"100"}]
			console.log(arr[1].data) // will throw error
			console.log(arr[1]?.data) // will print undefined

		Objects
			Objects are used to store Key value pairs, where key is always a string and value can be of any datatype

			Object Methods
				const obj = {a:11,b:12,c:13,d:14}
				Object.keys(objName) -> returns an array with all the keys in object ['a','b','c','d']
				Object.values(objName) -> returns an array with all the values in object [11,12,13,14]
				Object.entries(objName) -> returns an array with keys in 0 and value in 1 position eg. [['a',11],['b',12]....]

				Object.assign()
				Object.create()
			Enhanced Object literals
				Major Enhancements on Object literals are
				1. Setting variable alone creates a property in object with same variable name and sets it to it
				2. Functions can be configured in funcName(){} directly where funcName is considered as the key
				3. use [] in the key side to evalute any expression inside to arrive at a dynamic keyname
				const Address = {add1:"No 6", street:"Vivekanandar Theru",city:"Dubai main rd"}

				const Person = {
					Name:"Logan",
					Address, // same as Address: Address
					calcAge(age){  // same as calcAge : function(){}
						return 2021 - age
					},
					['Bini'+'Babu']:"dost" // using [] is used to set dynamic key name after evaluating expression inside it
				}
			Optional Chaining - es 2020
				Using ?. to access property of object is called Optional Chaining and its returns undefined as soon as property is not found in the object
				Scenarios
					const Person = {
						Name:"Logan",
						Address:{StreetNum:"No6"}
					}
					Person.Address.Address1.StreetName // throws unable to find property StreetName of undefined
					Person?.Address?.Address1?.StreetName // returns undefined right after Address1 without throwing error
					Person?.Address[Address1]?.StreetName // can be used with [] as well

					Person?.calcAge?.(1994) // method is invoked only if its available

		Sets
			Collection of unique values (kind of Hashset)
			Supports mixed dataTypes as well
			const tempSet = new Set(<Iterable>) // can be used with any iterable

			const tempSet = new Set([1,2,3,1,2,4,3]) // will store only unique values // result : [1,2,3,4]

			Set Methods
				tempSet.add(6) // adds element
				tempSet.delete(6) // removes element
				tempSet.size // returns size (length)
				tempSet.has(5) // returns true or false based on values being present in set
				tempSet.clear() // clears entire set

				Note: We can use for of to iterate through Sets

				Scenarios
					Remove duplicates from Array
					let arr = [1,2,3,4,5,1,2,4,2]
					arr = [...new Set(arr)] // set will remove duplicates and Spread operator gives new array from the set
		Maps
			Map is used to store Key value pair as well, but unlike objects Map can have keys and values of any datatype
				const mMap = new Map()
			Map Methods
				mMap.set(Key,value) // set value in key and returns new Map
				mMap.set(Key,value).set(Key1,value1) // set() can be chained as it returns new Map always
				
				mMap.get(key) // returns the value if key is present else undefined
				mMap.has(key) // returns booelan if key is present or not
				mMap.delete(key) // remove key
				mMap.clear() // clear map
				mMap.size // returns size (length)
				[...mMap.keys()] -> returns an array with all the keys in Mao ['a','b','c','d']
				[...mMap.values()] -> returns an array with all the values in Map` [11,12,13,14]
				[...mMap.entries()] -> returns an array with keys in 0 and value in 1 position eg. [['a',11],['b',12]....]
				[...mMap] -> same as above; Convert Map to Array

			const sMap = new Map([["Key","val"],["Key1","val1"]]) // to initialize a Map, use Array of Arrays syntax where 0 index is key and 1 index is value (similar to Object.entries())

			Maps can have following as key as well
				Arrays
				objects
				DOM element

			Note: All reference DataTypes if used as a key in map, should always be set with variable and not value
				mMap.set([1,2],"test");
				mMap.get([1,2]); // returns undefined as [1,2] is created twice and not referenced

				const arr=[1,2]
				mMap.set(arr,"test");
				mMap.get(arr); // will return "test"

			Convert Object to Map
				const jMap = new Map(Object.entries(objName)) // will create a Map based on Object
	Loop
		For of Loop
			Arrays
				const arr = ['a','b','c']

				for(const a of arr) console.log(a) // will print each index one by one

				Use arr.entries() method to get index in for of loop  
					for(const [index,element] of arr.entries()) console.log(`${index+1}:${element}`) //output: 1: a ....


	OOPS
		Programming Paradigm, using Classes and Objects
		Abstraction
			Hiding logic
		Encapsulation
			access modifiers, keeping things inside class itself
		Inheritance
			child extends parent
		Polymorphism
			child can override parent class methods

		Constrctor Function
			Constructor function does not work with Arrow function as it does not have it own this keyword
			Create a constructor Function with function definition & declaration
			To make it an actual constructor function use 'new' keyword when calling the function
			Using new funcName() does the following things
				1. Createa a new {} Object by default
				2. Upon calling the function, 'this' will point to newly created Object {}
				3. {} is linked to Prototype
				4. Automatically returns the created object

			const Person = function(Name,Age){
				this.Name = Name
				this.Age = Age
				console.log(this) // will print Person{}
			}

			new Person('Logan',27);

			Note: Never create a function/method inside constructor functions as it would reapeat the function unecessarily for each instance, instead use Prototype and inherit the method

		Prototype
			Person.prototype.funcName = function(){
				//any code
			}
			Person.prototype.Type = "Humans"

			Any property configured inside a Prototype Object will be available for all the objects created for Person

		Class
			Class is just syntax Enhancements but it is same as constructor function that returns an object
			Not hoisted
			Classes are always executed in strict mode

		